import collections
import logging
import os
import pickle
import uuid
import warnings

import apache_beam as beam
from apache_beam import __version__ as beam_version
from apache_beam.options import pipeline_options
from apache_beam.runners.interactive.display import pipeline_graph
from IPython import display
from IPython.core import magic

import klio
from klio.transforms import core
from klio_exec.commands import run
from klio_exec.commands.utils import console_utils
from klio import __version__ as klio_version
from klio_core import __version__ as klio_core_version
from klio_exec import __version__ as klio_exec_version

CONFIG_CONTENTS = """# File generated by klio-exec
c.InteractiveShellApp.extensions = ["klio_exec.commands.utils.ipython_ext"]
"""

RuntimeConfig = collections.namedtuple(
    "RuntimeConfig", ["image_tag", "direct_runner", "update", "blocking"]
)
JobConsoleConfig = collections.namedtuple(
    "JobConsoleConfig", [
        "image_name", 
        "direct_runner", 
        "docker_version", 
        "klio_cli_version",
        "config_file",
        "notebook",
    ]
)


@magic.magics_class
class KlioIPythonMagic(magic.Magics):
    """TODO: docstrings"""
    def __init__(self, shell, local_scope):
        super(KlioIPythonMagic, self).__init__(shell)
        self.local_scope = local_scope
        self._kpipeline = None

    def _get_runtime_config(self):
        image_tag = os.getenv("IMAGE_TAG")
        return RuntimeConfig(
            image_tag=image_tag,
            direct_runner=True,
            update=None,
            blocking=None,
        )

    def _get_job_console_config(self):
        return JobConsoleConfig(
            image_name=os.getenv("IMAGE_NAME"),
            direct_runner=True,
            docker_version=os.getenv("DOCKER_VERSION"),
            klio_cli_version=os.getenv("KLIO_CLI_VERSION"),
            config_file=os.getenv("ACTIVE_CONFIG_FILE"),
            notebook=True,
        )

    def _init_klio_pipeline(self):
        if self._kpipeline is not None:
            return self._kpipeline

        kctx = core.KlioContext()
        config = kctx.config
        runtime_conf = self._get_runtime_config()
        job_console_config = self._get_job_console_config()
        self._kpipeline = run.KlioPipeline(
            config.job_name, config, runtime_conf
        )
        return self._kpipeline

    def _get_klio_pipeline(self):
        kpipeline = self._init_klio_pipeline()
        options = kpipeline._get_pipeline_options()
        options.view_as(pipeline_options.StandardOptions).runner = "DirectRunner"
        pipeline = beam.Pipeline(options=options)
        kpipeline._setup_pipeline(pipeline)
        return pipeline

    def _get_original_pipeline_options(self):
        return self._kpipeline._get_pipeline_options()

    def _get_new_pipeline(self, runner=None, options=None):
        if options is None:
            options = self._kpipeline._get_pipeline_options()
        if runner is None:
            runner = "DirectRunner"
        options.view_as(pipeline_options.StandardOptions).runner = runner
        return beam.Pipeline(options=options)

    def _get_new_pipeline_options(self, config_dict=None):
        if config_dict is None:
            config_dict = {}
        # TODO: check to see if there's pipeline_options already in keys
        return pipeline_options.PipelineOptions().from_dictionary(config_dict)

    def _show_header(self):
        # TODO: update header examples to look like Jupyter prompt instead of k>>
        kctx = core.KlioContext()
        job_console_config = self._get_job_console_config()
        print(
            console_utils.HEADER_TMPL.format(
                klio_cli_version=job_console_config.klio_cli_version,
                docker_version=job_console_config.docker_version,
                image_name=job_console_config.image_name,
                klio_version=klio_version,
                klio_core_version=klio_core_version,
                klio_exec_version=klio_exec_version,
                config_path=job_console_config.config_file,
                beam_version=beam_version,
                job_name=kctx.config.job_name,
            )
        )

    def _show_graph(self, pipeline):
        g = pipeline_graph.PipelineGraph(pipeline)
        svg = g._graph.create_svg()
        print(
            "\u001b[38;2;117;152;248;1mNote: Rectangular nodes are transforms, "
            "circular nodes are PCollections\u001b[0m"
        )
        display.display(display.SVG(g._graph.create_svg()))

    @magic.line_magic
    def klioify(self, line):
        """TODO: docstrings"""
        warnings.simplefilter("ignore")
        # TODO: if line is empty, don't do anything special
        # TODO if line is provided, do something special?
        local_ns = self.shell.user_ns
        local_ns["kctx"] = core.KlioContext()
        local_ns["beam"] = beam
        local_ns["apache_beam"] = beam
        local_ns["klio"] = klio
        local_ns["handle_klio"] = klio.transforms.decorators.handle_klio
        local_ns["kpipeline"] = self._get_klio_pipeline()
        local_ns["show_header"] = self._show_header
        local_ns["get_original_pipeline"] = self._get_klio_pipeline
        local_ns["get_original_pipeline_options"] = self._get_original_pipeline_options
        local_ns["get_new_pipeline"] = self._get_new_pipeline
        local_ns["get_new_pipeline_options"] = self._get_new_pipeline_options
        local_ns["show_graph"] = self._show_graph
        self._show_header()
        # return line


# TODO: is this needed?
def load_ipython_extension(ipython):
    logging.error("XXX REGISTERING KLIO MAGIC FROM MODULE")

    klio_magic = KlioIPythonMagic(ipython, {"foo_init2": "bar_init2"})
    ipython.register_magics(klio_magic)


def generate_ipython_config():
    """TODO: docstrings"""
    user_path = os.path.expanduser("~")
    ipython_path = os.path.join(user_path, ".ipython")

    if not os.path.exists(ipython_path):
        print(f"Creating {ipython_path}")
        os.mkdir(ipython_path)

    profile_default_path = os.path.join(ipython_path, "profile_default")
    if not os.path.exists(profile_default_path):
        print(f"Creating {profile_default_path}")
        os.mkdir(profile_default_path)

    config_filepath = os.path.join(profile_default_path, "ipython_config.py")
    with open(config_filepath, "w") as f:
        f.write(CONFIG_CONTENTS)

